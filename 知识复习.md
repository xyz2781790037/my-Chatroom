---
title: 知识复习
comments: false
tags:
  - C++
  - muduo
  - 数据结构
excerpt: 小舟从此逝，江海寄余生
toc: false
date: 2025-08-18 20:10:56
cover: 'https://pic.netbian.com/uploads/allimg/250807/231552-1754579752e74d.jpg'
---
# 哈希冲突
定义：不同的 key，通过哈希函数算出来的**哈希值**相同。
### 解决哈希冲突的方法
#### （1）链地址法（Separate Chaining）
- 每个桶不是存一个元素，而是存一个 链表 / 动态数组 / 红黑树。
- 冲突的元素都插到链表里。
- 查找时，先找到桶，再在桶里的链表里比对 key。
- 如果某个桶里的链表过长，哈希表会把这条链表转成 平衡二叉树（红黑树）。
#### （2）开放寻址法（Open Addressing）
开放寻址（open addressing）不引入额外的数据结构，而是通过“**多次探测**”来处理哈希冲突，探测方式主要包括**线性探测、平方探测和多次哈希**等。
##### 线性探测
在开放寻址法里，所有数据都放在同一个哈希表数组里。
插入时，如果位置被占，就找“下一个”位置。
查找时，如果目标位置不是想要的元素，就按一定的规则往后找。
删除时，需要用特殊标记（懒删除），否则可能破坏查找路径。

不同的探测方式就是 **“冲突后往哪找”**的规则。
桶里面存的是不同的数据`(key,value)`,所以不会出现重复，但是桶满了就需要去扩容。
##### 平方探测
当发生冲突时，平方探测不是简单地跳过一个固
定的步数，而是跳过“探测次数的平方”的步数，即 1, 4, 9, … 步。
平方探测主要具有以下优势。
- 平方探测通过跳过探测次数平方的距离，试图缓解线性探测的聚集效应。
- 平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀。
然而，平方探测并不是完美的。
- 仍然存在聚集现象，即某些位置比其他位置更容易被占用。
- 由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它。
### 多次哈希
就是存多个哈希，如果第一个有了，那么就去第二个哈希找
#### （3）再哈希法（Rehashing）
为哈希表换一套更大的“桶数组”，并把现有元素按新桶数重新分布（重新插入）。
**什么时候触发**：装载因子超阈值
# 线程
### 写时复制(copy on write)
写时复制是一种资源管理优化技术。
- 当多个进程/线程共享同一份数据时，不立即复制数据。
- 只有在某个写操作发生时，才真正复制一份数据给写入方，其他保持共享。
优点：
```
- 减少不必要的内存拷贝
- 提高性能（特别是在大数据结构只读时）
```
### 进程与资源共享
#### fork 之后
文件描述符表被“复制”到子进程：父子各有一份 FD 表，但每个条目都指向同一个内核文件对象（struct file）。
👉 共享：文件偏移量、打开标志（如 O_APPEND、O_NONBLOCK）
👉 引用计数 +1：直到父子都把该 fd close()，内核对象才被回收

- 内存：地址空间采用 COW（写时复制），读共享、写时分离
- 其他：环境变量、cwd、umask、信号处理方式等按 POSIX 规则继承副本
```
误区澄清：不是“谁关谁独占”。父或子 close(fd) 只是把该进程对文件对象的引用计数减 1；所有引用清零才真正关闭。
```
#### exec 之后
当前进程用新程序镜像替换地址空间
保留的内核对象：默认情况下，打开的 FD 会被继承到新程序；
但标了 FD_CLOEXEC（O_CLOEXEC/fcntl(F_SETFD, FD_CLOEXEC)）的 fd 会在 exec 时自动关闭（防泄漏）
信号处置、内存映射等大多被重置为默认或新程序态

**结论：fork 共享、exec 选择性继承（靠 CLOEXEC 控制）。**
# muduo的Buffer
Muduo 的 Buffer 本质上是一个 连续的字节数组，它在逻辑上被分为三段：
- prependable bytes: 已经被读走的数据，空闲出来的区域。

- readable bytes: 存放已经写入、等待用户读取的数据（readIndex -> writerIndex 之间）。

- writable bytes: 可用来写新数据的空间（writerIndex -> buffer.size() 之间）。
### 逻辑
实际是一直往后写直到空间不够，不够的时候，会向前挪动，然后：
1. 空间足够时，直接写入
2. 空间不够时，先扩容，再写入
### 为什么不采用“循环缓冲区”？
- **代码复杂度高**：循环 buffer 需要处理 wrap-around（分两段写），增加系统调用成本。
- **数据迁移更直观**：一次 memmove 就能完成挪动。
# muduo其他
Channel是事件设置，Epoller是事件更新，EventLoop是统一调度(事件调用)
具体：[muduo](https://xyz2781790037.github.io/2025/08/18/muduo/)